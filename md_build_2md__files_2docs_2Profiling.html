<!-- HTML header for doxygen 1.9.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=11"/>
    <meta name="generator" content="Doxygen 1.9.8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>CppDSA: Profiling Tools and Techniques for C++ Projects</title>
    <link href="tabs.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link rel="icon" href="logo.png" type="image/png" />
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript" src="doxygen-awesome-tabs.js"></script>
    <script type="text/javascript">
      DoxygenAwesomeDarkModeToggle.lightModeIcon = 'üåû';
      // icon from https://fonts.google.com/icons
      DoxygenAwesomeDarkModeToggle.darkModeIcon = `<svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="#009793"><g><rect fill="none" height="24" width="24"/></g><g><g><path d="M8.1,14.15C9.77,14.63,11,16.17,11,18c0,0.68-0.19,1.31-0.48,1.87c0.48,0.09,0.97,0.14,1.48,0.14 c1.48,0,2.9-0.41,4.13-1.15c-2.62-0.92-5.23-2.82-6.8-5.86C7.74,9.94,7.78,7.09,8.29,4.9c-2.57,1.33-4.3,4.01-4.3,7.1c0,0,0,0,0,0 c0.01,0,0.01,0,0.02,0C5.66,12,7.18,12.83,8.1,14.15z" opacity=".3"/><path d="M19.78,17.51c-2.47,0-6.57-1.33-8.68-5.43C8.77,7.57,10.6,3.6,11.63,2.01C6.27,2.2,1.98,6.59,1.98,12 c0,0.14,0.02,0.28,0.02,0.42C2.61,12.16,3.28,12,3.98,12c0,0,0,0,0,0c0-3.09,1.73-5.77,4.3-7.1C7.78,7.09,7.74,9.94,9.32,13 c1.57,3.04,4.18,4.95,6.8,5.86c-1.23,0.74-2.65,1.15-4.13,1.15c-0.5,0-1-0.05-1.48-0.14c-0.37,0.7-0.94,1.27-1.64,1.64 c0.98,0.32,2.03,0.5,3.11,0.5c3.5,0,6.58-1.8,8.37-4.52C20.18,17.5,19.98,17.51,19.78,17.51z"/><path d="M7,16l-0.18,0C6.4,14.84,5.3,14,4,14c-1.66,0-3,1.34-3,3s1.34,3,3,3c0.62,0,2.49,0,3,0c1.1,0,2-0.9,2-2 C9,16.9,8.1,16,7,16z"/></g></g></svg>`;
      // All customizations must be applied before calling DoxygenAwesomeDarkModeToggle.init()!
      DoxygenAwesomeDarkModeToggle.init();
      DoxygenAwesomeFragmentCopyButton.init();
      DoxygenAwesomeParagraphLink.init();
      DoxygenAwesomeInteractiveToc.init();
      DoxygenAwesomeTabs.init();
    </script>
</head>
<body>
    <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
    <div id="titlearea">
        <table cellspacing="0" cellpadding="0">
            <tbody>
                <tr id="projectrow">
                    <td id="projectalign">
                        <div id="projectname">CppDSA
                        </div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>
    <!-- end header part --><!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_build_2md__files_2docs_2Profiling.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Profiling Tools and Techniques for C++ Projects</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md16">Table of Contents</a></li>
<li class="level1"><a href="#autotoc_md18">Introduction</a></li>
<li class="level1"><a href="#autotoc_md20">Preparing Your Code for Profiling</a></li>
<li class="level1"><a href="#autotoc_md22">Profiling with gprof</a><ul><li class="level2"><a href="#autotoc_md23">What is gprof?</a></li>
<li class="level2"><a href="#autotoc_md24">Setup and Usage</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md26">Profiling with Valgrind (Callgrind)</a><ul><li class="level2"><a href="#autotoc_md27">What is Valgrind/Callgrind?</a></li>
<li class="level2"><a href="#autotoc_md28">Setup and Usage</a></li>
<li class="level2"><a href="#autotoc_md29">Analyzing Results with KCachegrind</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md31">Profiling with perf (Linux)</a><ul><li class="level2"><a href="#autotoc_md32">What is perf?</a></li>
<li class="level2"><a href="#autotoc_md33">Setup and Usage</a></li>
<li class="level2"><a href="#autotoc_md34">Installing perf on WSL2</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md36">Debug vs. Release Builds</a></li>
<li class="level1"><a href="#autotoc_md38">Integrating Profiling and Benchmarking in CI/CD</a><ul><li class="level2"><a href="#autotoc_md39">Current Landscape</a></li>
<li class="level2"><a href="#autotoc_md40">Example in GitHub Actions</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md42">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="autotoc_md14"></a></p>
<p>This guide provides a deep dive into several popular profiling tools and techniques used to analyze and optimize C++ code. It covers <b>gprof</b>, <b>Valgrind (Callgrind)</b>, and <b>perf</b>. Additionally, it discusses how to prepare your builds for profiling, the differences between debug and release modes, and considerations for integrating profiling/benchmarking data into CI/CD pipelines.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md16"></a>
Table of Contents</h1>
<ol type="1">
<li>Introduction</li>
<li>Preparing Your Code for Profiling</li>
<li>Profiling with gprof<ul>
<li>What is gprof?</li>
<li>Setup and Usage</li>
</ul>
</li>
<li>Profiling with Valgrind (Callgrind)<ul>
<li>What is Valgrind/Callgrind?</li>
<li>Setup and Usage</li>
<li>Analyzing Results with KCachegrind</li>
</ul>
</li>
<li>Profiling with perf (Linux)<ul>
<li>What is perf?</li>
<li>Setup and Usage</li>
</ul>
</li>
<li>Debug vs. Release Builds</li>
<li>Integrating Profiling and Benchmarking in CI/CD</li>
<li>Conclusion</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md18"></a>
Introduction</h1>
<p>Profiling is an essential practice for understanding where your program spends its time and identifying performance bottlenecks. Unlike code coverage‚Äîwhich is often reported via services like Codecov or Coveralls‚Äîprofiling typically requires collecting raw performance data that is then analyzed with specialized tools. Each tool provides different insights:</p>
<ul>
<li><b>gprof</b>: Generates a flat profile and call graph by instrumenting the code (requires <code>-pg</code>).</li>
<li><b>Valgrind (Callgrind)</b>: Provides detailed call graphs and metrics on function call counts and execution paths.</li>
<li><b>perf</b>: Offers a wide range of profiling options on Linux, including sampling-based performance data and live views with <code>perf top</code>.</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md20"></a>
Preparing Your Code for Profiling</h1>
<p>Before profiling, you need to prepare your build:</p><ul>
<li><b>Release Mode</b>: Always profile optimized (release mode) builds. This ensures that the performance data reflects real-world usage, as compiler optimizations (like inlining and loop unrolling) are enabled.</li>
<li><b>Profiling Flags</b>:<ul>
<li>For <b>gprof</b>, compile and link with <code>-pg</code>. This instruments your code to produce a <code>gmon.out</code> file at runtime.</li>
<li>Tools like <b>Valgrind</b> and <b>perf</b> do not require special compiler flags, but ensure that debug symbols (using <code>-g</code>) are available for more meaningful analysis.</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md22"></a>
Profiling with gprof</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
What is gprof?</h2>
<p><b>gprof</b> is a GNU profiler that collects performance data by instrumenting your executable. It provides:</p><ul>
<li>A <b>flat profile</b>: Time spent in each function.</li>
<li>A <b>call graph</b>: Who calls whom and how often.</li>
</ul>
<h2><a class="anchor" id="autotoc_md24"></a>
Setup and Usage</h2>
<ol type="1">
<li><b>Compile with <code>-pg</code></b>:<ul>
<li>Modify your CMake configuration (or build system) to add <code>-pg</code> to both compile and link flags: <div class="fragment"><div class="line">set(CMAKE_CXX_FLAGS_RELEASE &quot;${CMAKE_CXX_FLAGS_RELEASE} -pg&quot;)</div>
<div class="line">set(CMAKE_EXE_LINKER_FLAGS_RELEASE &quot;${CMAKE_EXE_LINKER_FLAGS_RELEASE} -pg&quot;)</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Build in Release Mode</b>:<ul>
<li>Ensure you are using a release build to get realistic performance data: <div class="fragment"><div class="line">cmake .. -DCMAKE_BUILD_TYPE=Release</div>
<div class="line">make -j$(nproc)</div>
</div><!-- fragment --></li>
</ul>
</li>
<li><b>Run the Executable</b>:<ul>
<li>Run your target (e.g., <code>./vector_benchmark</code>). This generates a <code>gmon.out</code> file.</li>
</ul>
</li>
<li><b>Analyze with gprof</b>:<ul>
<li>Run: <div class="fragment"><div class="line">gprof ./vector_benchmark gmon.out &gt; profile.txt</div>
</div><!-- fragment --></li>
<li>Open <code>profile.txt</code> to review the detailed profiling report.</li>
</ul>
</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md26"></a>
Profiling with Valgrind (Callgrind)</h1>
<h2><a class="anchor" id="autotoc_md27"></a>
What is Valgrind/Callgrind?</h2>
<p><b>Valgrind</b> is a powerful instrumentation framework that includes the <b>Callgrind</b> tool, which is used for profiling. It provides:</p><ul>
<li>Detailed call graphs.</li>
<li>Metrics on function call counts and instruction counts.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
Setup and Usage</h2>
<ol type="1">
<li><b>Run under Callgrind</b>:<ul>
<li>Execute your program with Callgrind: <div class="fragment"><div class="line">valgrind --tool=callgrind ./vector_benchmark</div>
</div><!-- fragment --></li>
<li>This produces an output file (e.g., <code>callgrind.out.&lt;pid&gt;</code>).</li>
</ul>
</li>
<li><b>Analyze Output</b>:<ul>
<li>Use command-line tools: <div class="fragment"><div class="line">callgrind_annotate callgrind.out.&lt;pid&gt;</div>
</div><!-- fragment --></li>
<li>Or, for a graphical interface, see the next section.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md29"></a>
Analyzing Results with KCachegrind</h2>
<ul>
<li><b>KCachegrind</b>: A graphical viewer for Callgrind data.<ul>
<li>Install KCachegrind (or QCachegrind on some distributions).</li>
<li>Open the output file: <div class="fragment"><div class="line">kcachegrind callgrind.out.&lt;pid&gt;</div>
</div><!-- fragment --></li>
<li>Explore the call graph, identify hotspots, and analyze the call paths.</li>
</ul>
</li>
</ul>
<hr  />
<h1><a class="anchor" id="autotoc_md31"></a>
Profiling with perf (Linux)</h1>
<h2><a class="anchor" id="autotoc_md32"></a>
What is perf?</h2>
<p><b>perf</b> is a Linux profiling tool that uses sampling-based techniques. It provides:</p><ul>
<li>A <b>flat profile</b>.</li>
<li><b>Call graphs</b>.</li>
<li>Live monitoring (via <code>perf top</code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md33"></a>
Setup and Usage</h2>
<ol type="1">
<li><b>Record Performance Data</b>:<ul>
<li>Run your executable with perf: <div class="fragment"><div class="line">perf record -g ./vector_benchmark</div>
</div><!-- fragment --></li>
<li>This collects data and creates a <code>perf.data</code> file.</li>
</ul>
</li>
<li><b>Analyze the Data</b>:<ul>
<li>Use: <div class="fragment"><div class="line">perf report</div>
</div><!-- fragment --></li>
<li>This opens an interactive interface where you can navigate through function calls and hotspots.</li>
</ul>
</li>
<li><b>Live Profiling</b>:<ul>
<li>Run: <div class="fragment"><div class="line">perf top</div>
</div><!-- fragment --></li>
<li>This command shows real-time profiling data similar to the Unix <code>top</code> command.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md34"></a>
Installing perf on WSL2</h2>
<p>Install dependencies (more may be needed): </p><div class="fragment"><div class="line">sudo apt update &amp;&amp; sudo apt install build-essential flex bison libssl-dev libelf-dev bc python3 pahole cpio pkg-config</div>
</div><!-- fragment --><p>Install perf using <a href="https://stackoverflow.com/a/60276918/3049315">this guide</a>.</p>
<p>Install the <a href="https://learn.microsoft.com/en-us/community/content/wsl-user-msft-kernel-v6">custom WSL2 kernel</a> if necessary.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md36"></a>
Debug vs. Release Builds</h1>
<ul>
<li><b>Debug Builds</b>: Usually compiled with no optimizations and include extra debug symbols. They are slower and can provide different performance characteristics.</li>
<li><b>Release Builds</b>: Compiled with optimizations (e.g., <code>-O2</code> or <code>-O3</code>) to reflect production performance. Profiling release builds is recommended to understand real-world performance.</li>
</ul>
<p>For profiling, always use <b>release builds with debug symbols</b> (<code>-g</code> along with optimization flags) to achieve accurate and useful performance data.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md38"></a>
Integrating Profiling and Benchmarking in CI/CD</h1>
<h2><a class="anchor" id="autotoc_md39"></a>
Current Landscape</h2>
<ul>
<li><b>Code Coverage</b>: Tools like Codecov or Coveralls are widely adopted for integrating code coverage data.</li>
<li><b>Profiling/Benchmarking</b>: There is no single, universal service for profiling results akin to code coverage services. However, you can:<ul>
<li><b>Store Artifacts</b>: CI/CD pipelines (GitHub Actions, GitLab CI/CD) can archive profiling output files (e.g., <code>gmon.out</code>, <code>callgrind.out.*</code>, <code>perf.data</code>) as artifacts for later analysis.</li>
<li><b>JSON Output</b>: Some benchmarking tools (e.g., Google Benchmark) can output results in JSON format, which can be published to custom dashboards or parsed by CI scripts.</li>
<li><b>Automated Reporting</b>: Integrate scripts that run benchmarks and then post summarized results to a Slack channel, a dashboard, or as comments on a merge request.</li>
<li><b>Custom CI Jobs</b>: Create additional jobs in your CI pipeline that run profiling/benchmarking tools and then use artifact upload steps to preserve the results for offline analysis.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md40"></a>
Example in GitHub Actions</h2>
<p>For instance, you could add a step to run Google Benchmark with JSON output and then use an action to upload the JSON file as an artifact: </p><div class="fragment"><div class="line">- name: Run C++ benchmarks with JSON output</div>
<div class="line">  working-directory: cpp/build</div>
<div class="line">  run: |</div>
<div class="line">    ./vector_benchmark --benchmark_format=json &gt; benchmark_results.json</div>
<div class="line">- name: Upload Benchmark Results</div>
<div class="line">  uses: actions/upload-artifact@v3</div>
<div class="line">  with:</div>
<div class="line">    name: benchmark-results</div>
<div class="line">    path: cpp/build/benchmark_results.json</div>
</div><!-- fragment --><p> This way, while there isn‚Äôt a standardized ‚Äúprofiling dashboard‚Äù like Codecov, you can still capture and share performance data within your CI/CD workflow.</p>
<hr  />
<h1><a class="anchor" id="autotoc_md42"></a>
Conclusion</h1>
<p>This guide has detailed the following:</p><ul>
<li><b>gprof</b>: Requires compiling with <code>-pg</code>; good for flat profiles and call graphs.</li>
<li><b>Valgrind (Callgrind)</b>: Provides detailed call graphs and instruction-level metrics; best analyzed with KCachegrind.</li>
<li><b>perf</b>: A versatile Linux tool for sampling-based profiling with live monitoring capabilities.</li>
</ul>
<p>While integration of profiling results into CI/CD isn‚Äôt as standardized as for code coverage, you can still archive artifacts, use JSON outputs, and create custom reporting scripts to share performance data across your team.</p>
<p>Use this guide as a reference for setting up and using these profiling tools in your project, and adjust your CI/CD pipelines to capture and analyze performance data as needed. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
      <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
    </ul>
  </div>
  </body>
  </html>